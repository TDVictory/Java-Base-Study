# 必要条件
- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中每个进程都在等待下一个进程所占用的资源。

# 处理方法
主要有四种应对死锁的处理方法：
- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免
# 鸵鸟策略
把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
# 死锁检测与死锁恢复
不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。
## 1.每种类型一个资源的死锁检测
每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
## 2.每种类型多个资源的死锁检测
每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。
## 3.死锁恢复
- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复
# 死锁预防
在程序运行前预防发生死锁。
## 1.破坏互斥条件
例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

可以同时发生多个互斥条件，但是由守护进程选择某个条件进行执行。
## 2.破坏占有和等待条件
一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。防止某些进程在运行过程中请求新的资源不得而旧资源无法释放。
## 3.破坏不可抢占条件
## 4.破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。
# 死锁避免
在程序运行时避免发生死锁。
## 1.安全状态
定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然**存在某种调度次序能够使得每一个进程运行完毕**，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。
## 2.单个资源的银行家算法
一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

## 3.多个资源的银行家算法
检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。

整体来说就是将资源可用进行合计，当成单个资源来进行单个资源的银行家算法。
